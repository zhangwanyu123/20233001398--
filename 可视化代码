import os
import hashlib
import subprocess
import threading
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding
import tkinter as tk
from tkinter import filedialog, messagebox, ttk

class FileEncryptTool:
    def __init__(self, root):
        self.root = root
        self.root.title("通用文件加密工具（含证书生成）")
        self.root.geometry("800x600")  
        self.root.resizable(True, True)  
        
        # 核心参数
        self.file_path = tk.StringVar()
        self.key_file = "aes_key.txt"
        self.iv_file = "aes_iv.txt"
        self.transfer_enc_file = "文件传输后的密文.txt.enc"
        # 证书文件路径
        self.cert_file = "server.crt"
        self.cert_key_file = "server.key"
        
        # 构建UI
        self._build_ui()
        
    def _build_ui(self):
        # 1. 待加密/解密文件选择
        tk.Label(self.root, text="待加密/解密文件：", anchor="w").grid(
            row=0, column=0, padx=5, pady=5, sticky="nsew"
        )
        tk.Entry(self.root, textvariable=self.file_path, width=40).grid(
            row=0, column=1, padx=5, pady=5, sticky="nsew"
        )
        tk.Button(self.root, text="选择文件", command=self._select_file).grid(
            row=0, column=2, padx=5, pady=5, sticky="nsew"
        )
        
        # 2. 密钥/IV操作
        tk.Label(self.root, text="密钥/IV文件：", anchor="w").grid(
            row=1, column=0, padx=5, pady=5, sticky="nsew"
        )
        tk.Label(self.root, text=f"(密钥：{self.key_file} | IV：{self.iv_file})", anchor="w").grid(
            row=1, column=1, padx=5, pady=5, sticky="nsew"
        )
        tk.Button(self.root, text="生成密钥/IV", command=self._generate_key_iv).grid(
            row=1, column=2, padx=5, pady=5, sticky="nsew"
        )
        
        # 3. 证书管理（恢复生成按钮）
        tk.Label(self.root, text="证书管理：", anchor="w").grid(
            row=2, column=0, padx=5, pady=5, sticky="nsew"
        )
        tk.Label(self.root, text=f"(证书：{self.cert_file} | 私钥：{self.cert_key_file})", anchor="w").grid(
            row=2, column=1, padx=5, pady=5, sticky="nsew"
        )
        tk.Button(self.root, text="生成自签名证书", command=self._generate_certificate).grid(
            row=2, column=2, padx=5, pady=5, sticky="nsew"
        )
        
        # 4. 核心功能按钮
        btn_frame = ttk.Frame(self.root)
        btn_frame.grid(row=3, column=1, columnspan=2, padx=5, pady=10, sticky="nsew")
        btn_frame.columnconfigure(0, weight=1)
        btn_frame.columnconfigure(1, weight=1)
        tk.Button(btn_frame, text="加密文件", command=self._encrypt_file, width=15).grid(
            row=0, column=0, padx=5, pady=5, sticky="nsew"
        )
        tk.Button(btn_frame, text="解密文件", command=self._decrypt_file, width=15).grid(
            row=0, column=1, padx=5, pady=5, sticky="nsew"
        )
        
        # 5. 运行日志
        tk.Label(self.root, text="运行日志：", anchor="nw").grid(
            row=4, column=0, padx=5, pady=5, sticky="nsew"
        )
        self.log_text = tk.Text(self.root, width=70, height=15)
        self.log_text.grid(
            row=4, column=1, columnspan=2, padx=5, pady=5, sticky="nsew"
        )
        scrollbar = ttk.Scrollbar(self.root, command=self.log_text.yview)
        scrollbar.grid(row=4, column=3, sticky="ns")
        self.log_text.config(yscrollcommand=scrollbar.set)
        
    def _log(self, msg):
        self.log_text.insert(tk.END, f"[INFO] {msg}\n")
        self.log_text.see(tk.END)
        self.root.update()
        
    def _select_file(self):
        file = filedialog.askopenfilename(title="选择文件", filetypes=[("所有文件", "*.*")])
        if file:
            self.file_path.set(file)
            self._log(f"已选择文件：{file}")
            
    def _generate_key_iv(self):
        try:
            key = os.urandom(16)
            iv = os.urandom(16)
            with open(self.key_file, "wb") as f:
                f.write(key)
            with open(self.iv_file, "wb") as f:
                f.write(iv)
            self._log(f"成功生成密钥文件：{os.path.abspath(self.key_file)}")
            self._log(f"成功生成IV文件：{os.path.abspath(self.iv_file)}")
            messagebox.showinfo("成功", "密钥/IV文件生成完成！")
        except Exception as e:
            self._log(f"生成密钥/IV失败：{str(e)}")
            messagebox.showerror("错误", f"生成失败：{str(e)}")
    
    def _generate_certificate(self):
        """调用OpenSSL生成自签名证书（彻底解决Windows编码冲突）"""
        def cert_task():
            try:
                # 1. 检查OpenSSL文件是否存在
                openssl_path = r"D:\密码工程实验\实验3 OpenSSL\openssl-1.1.1b\win32-debug\bin\openssl.exe"
                if not os.path.exists(openssl_path):
                    raise Exception(f"未找到OpenSSL可执行文件：{openssl_path}")
                
                # 2. 生成私钥（2048位RSA）
                self._log("开始生成证书私钥...")
                gen_key_cmd = [
                    openssl_path, "genrsa", "-out", self.cert_key_file, "2048"
                ]
                # 关键修复：不捕获输出，重定向到空，避免编码解码
                subprocess.run(
                    gen_key_cmd, 
                    check=True, 
                    stdout=subprocess.DEVNULL,  # 忽略标准输出
                    stderr=subprocess.DEVNULL,  # 忽略标准错误
                    shell=True  # Windows下必须加，避免路径解析问题
                )
                self._log(f"生成证书私钥：{os.path.abspath(self.cert_key_file)}")
                
                # 3. 生成自签名证书（自动创建简化配置文件）
                self._log("开始生成自签名证书...")
                # 先检查/创建simple.cnf（避免依赖系统配置文件）
                cnf_path = "simple.cnf"
                if not os.path.exists(cnf_path):
                    cnf_content = """[req]
prompt = no
distinguished_name = dn
x509_extensions = v3_ca

[dn]
C = CN
ST = Henan
L = Nanyang
O = Xinye
OU = Xinye
CN = zwy

[v3_ca]
basicConstraints = CA:TRUE
subjectAltName = DNS:localhost
"""
                    with open(cnf_path, "w", encoding="ANSI") as f:
                        f.write(cnf_content)
                    self._log(f"自动创建简化配置文件：{cnf_path}")
                
                gen_cert_cmd = [
                    openssl_path, "req", "-new", "-x509", "-key", self.cert_key_file,
                    "-out", self.cert_file, "-days", "365",
                    "-config", cnf_path  # 使用本地简化配置
                ]
                # 同样忽略输出，避免编码冲突
                subprocess.run(
                    gen_cert_cmd, 
                    check=True, 
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    shell=True
                )
                self._log(f"生成自签名证书：{os.path.abspath(self.cert_file)}")
                
                messagebox.showinfo("成功", "自签名证书生成完成！")
            except subprocess.CalledProcessError as e:
                self._log(f"OpenSSL命令执行失败：返回码{e.returncode}")
                messagebox.showerror("错误", "证书生成失败（命令执行错误）\n请检查：\n1. OpenSSL路径是否正确\n2. 以管理员身份运行工具")
            except Exception as e:
                self._log(f"生成证书失败：{str(e)}")
                messagebox.showerror("错误", f"生成失败：{str(e)}")
        
        # 启动线程执行，避免UI卡死
        threading.Thread(target=cert_task).start()
            
    def _read_key_iv(self):
        try:
            if not os.path.exists(self.key_file) or not os.path.exists(self.iv_file):
                raise Exception("密钥/IV文件不存在，请先点击「生成密钥/IV」")
            with open(self.key_file, "rb") as f:
                key = f.read()
            with open(self.iv_file, "rb") as f:
                iv = f.read()
            if len(key) != 16 or len(iv) != 16:
                raise Exception("密钥/IV长度错误（需16字节）")
            return key, iv
        except Exception as e:
            self._log(f"读取密钥/IV失败：{str(e)}")
            messagebox.showerror("错误", f"读取失败：{str(e)}")
            return None, None
            
    def _encrypt_file(self):
        def encrypt_task():
            file_path = self.file_path.get().strip()
            if not file_path or not os.path.exists(file_path):
                self._log("加密失败：请选择有效文件")
                return
            key, iv = self._read_key_iv()
            if not key or not iv:
                return
            try:
                with open(file_path, "rb") as f:
                    data = f.read()
                padder = padding.PKCS7(algorithms.AES.block_size).padder()
                padded_data = padder.update(data) + padder.finalize()
                cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
                encryptor = cipher.encryptor()
                encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
                
                enc_file = f"{file_path}.enc"
                with open(enc_file, "wb") as f:
                    f.write(encrypted_data)
                self._log(f"加密完成，基础密文文件：{os.path.abspath(enc_file)}")
                
                with open(self.transfer_enc_file, "wb") as f:
                    f.write(encrypted_data)
                self._log(f"生成传输后密文文件：{os.path.abspath(self.transfer_enc_file)}")
                
                hash_obj = hashlib.sha256(encrypted_data)
                self._log(f"密文SHA256哈希：{hash_obj.hexdigest()}")
                messagebox.showinfo("成功", f"加密完成！\n基础密文：{enc_file}\n传输密文：{self.transfer_enc_file}")
            except Exception as e:
                self._log(f"加密失败：{str(e)}")
                messagebox.showerror("错误", f"加密失败：{str(e)}")
        
        threading.Thread(target=encrypt_task).start()
        
    def _decrypt_file(self):
        def decrypt_task():
            file_path = self.file_path.get().strip()
            if not file_path or not os.path.exists(file_path):
                self._log("解密失败：请选择有效文件")
                return
            if not file_path.endswith(".enc"):
                self._log("解密失败：仅支持加密后的.enc文件")
                return
            key, iv = self._read_key_iv()
            if not key or not iv:
                return
            try:
                with open(file_path, "rb") as f:
                    encrypted_data = f.read()
                cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
                decryptor = cipher.decryptor()
                padded_data = decryptor.update(encrypted_data) + decryptor.finalize()
                unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
                decrypted_data = unpadder.update(padded_data) + unpadder.finalize()
                
                dec_file = file_path.replace(".enc", "_decrypted")
                with open(dec_file, "wb") as f:
                    f.write(decrypted_data)
                self._log(f"解密完成！解密文件：{os.path.abspath(dec_file)}")
                messagebox.showinfo("成功", f"解密完成！\n解密文件：{dec_file}")
            except Exception as e:
                self._log(f"解密失败：{str(e)}")
                messagebox.showerror("错误", f"解密失败：{str(e)}")
        
        threading.Thread(target=decrypt_task).start()

if __name__ == "__main__":
    os.environ["CRYPTGRAPHY_OPENSSL_NO_LEGACY"] = "1"
    root = tk.Tk()
    app = FileEncryptTool(root)
    root.mainloop()
